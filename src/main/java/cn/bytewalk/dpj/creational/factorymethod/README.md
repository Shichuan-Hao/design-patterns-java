## 工厂方法

亦称：虚拟构造函数、Virtual Constructor、Factory Method

### 意图
工厂方法设计模式是一种创建型设计模式，其是在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。
![](factory-method-zh.png)

### 问题
想象一下，你正在开发一款物流管理应用。

最初的版本只能处理卡车运输，因此大部分代码都在位于名为 `Truck` 的类中。

一段时间以后，这款应用变得极受欢迎，您每天都能收到十几次来自海运公司的请求，希望能够支持海上物流功能。

![如果代码其余部分与现有类已经存在耦合关系，向程序中添加新类就没有那么容易](problem1-zh.png)

虽然这是一个好消息。但是对代码的改造带来了困难。因为目前，大部分代码都与 `Truck` 类相关。在程序中添加``类需要修改管不代码。更坏的是，
如果你以后在程序中支持另外一种运输方式，很可能需要再次对这些代码进行大幅修改。

最后，你不得不编写繁复的代码，根据不同的运输对象类，在应用中进行不同的处理。

### 解决方案
工厂模式建议我们，不直接使用 `new` 运算符创建，而是使用特殊的工厂方法代替对对象构造函数的直接调用，即使用 `new` 运算符创建对象的操作改在工厂方法中调用。工厂返回的对象通常被成为 "产品"。

这种改变，初看起来可能毫无意义：我们只是改变了程序中调用构造函数的位置而已。但是，仔细想一想，现在我们可以在子类中重写工厂方法，从而改变其创建产品的类型。

需要注意的是：只有这些产品具有共同的基类或者接口时，子类才能返回不同类型的产品，同时基类中的工厂方法还将其返回类型声明为这一共有接口。

比如：
- `卡车（Truck）` 和`轮船（Ship）`类都必须实现`运输（Transport）`接口，该接口声明了一个名为 `deliver（交付）`的方法
- 每个类都将以不同的方式实现该方法：
  - 卡车走陆路交付货物
  - 轮船走海路交付货物
- `陆路运输（RoadLogistics）`类中的工厂方法返回卡车对象
- `海路运输（SeaLogistics）`类中的工厂方法返回轮船对象

调用工厂方法的代码（通常被称为客户端）不需要了解子类返回实际对象之间的差别。客户端将所有产品视为抽象的运输。
客户端虽然知道所有运输对象都提供了交付方法，但是并不关系其具体实现方式

![工厂方法模式结构](factory-method-structure.png)


1. 产品（Product）将会对接口进行声明。对于所有由创建者及其子类构建的对象，这些接口都是通用的。
2. 具体产品（Concrete Products）是产品接口的不同实现。
3. 创建者（Creator）声明返回产品对象的工厂方法。该方法的返回对象类型必须与产品接口相匹配。
    > 我们可以将工厂方法声明为抽象方法，强制要求每个子类以不同方式实现该方法。或者，我们也可以在基础工厂方法中返回默认产品类型。\
    需要注意的是：尽管它的名字是创建者，但它最主要的职责并不是创建产品。一般情况下，创建者类包含一些与产品相关的核心业务逻辑。工厂
    方法将这些逻辑处理从具体产品类中分离出来。比如，大型软件开发公司拥有程序员培训部门。但是，这些公司的主要工作还是编写代码，而非生产程序员。
4. 具体创建者（Concrete Creators）将会重写基础工厂方法，使其返回不同类型的产品。
    > 注意，并不一定每次调用工厂方法都会创建新的实例。工厂方法也可以返回缓存、对象池或其他来源的已有对象。

### 伪代码
下面演示了如何使用工厂方法开发跨平台 UI（用户界面）组件，并同时避免客户代码与具体 UI 类之间的耦合。


基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 
Windows 系统中的按钮在 Linux 系统中仍然是按钮。

如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 
那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 
同时在屏幕上根据 Windows 样式渲染按钮。

如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 
这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。

你可以使用此方法开发其他 UI 组件。 不过，每向对话框中添加一个新的工厂方法, 你就离抽象工厂模式更近一步。 我们将在稍后谈到这个模式。
```
// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供
// 该方法的实现。
class Dialog is
    // 创建者还可提供一些工厂方法的默认实现。
    abstract method createButton():Button

    // 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务
    // 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方
    // 法并使其返回不同类型的产品来间接修改业务逻辑。
    method render() is
        // 调用工厂方法创建一个产品对象。
        Button okButton = createButton()
        // 现在使用产品。
        okButton.onClick(closeDialog)
        okButton.render()


// 具体创建者将重写工厂方法以改变其所返回的产品类型。
class WindowsDialog extends Dialog is
    method createButton():Button is
        return new WindowsButton()

class WebDialog extends Dialog is
    method createButton():Button is
        return new HTMLButton()


// 产品接口中将声明所有具体产品都必须实现的操作。
interface Button is
    method render()
    method onClick(f)

// 具体产品需提供产品接口的各种实现。
class WindowsButton implements Button is
    method render(a, b) is
        // 根据 Windows 样式渲染按钮。
    method onClick(f) is
        // 绑定本地操作系统点击事件。

class HTMLButton implements Button is
    method render(a, b) is
        // 返回一个按钮的 HTML 表述。
    method onClick(f) is
        // 绑定网络浏览器的点击事件。


class Application is
    field dialog: Dialog

    // 程序根据当前配置或环境设定选择创建者的类型。
    method initialize() is
        config = readApplicationConfigFile()

        if (config.OS == "Windows") then
            dialog = new WindowsDialog()
        else if (config.OS == "Web") then
            dialog = new WebDialog()
        else
            throw new Exception("错误！未知的操作系统。")

    // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口
    // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子
    // 类传递给客户端。
    method main() is
        this.initialize()
        dialog.render()
```
### 适用场景
**场景一：当您在编写代码时，如果无法预知对象确切类别及其依赖关系时** 

**场景二：如果您希望用户能够扩展您的软件库或框架的内部组件时** 

**场景三：如果您希望复用现有对象来节省系统资源，而不是每次都重新创建对象时**


### 实现方式

1. 让所有产品都遵循同一接口，该接口必须声明对所有产品都有意义的方法。
2. 在创建类中添加一个空的工厂方法，该方法的返回类型必须遵循通用的产品接口。
3. 在创建者代码中，找到对于产品构造函数的所有引用。将他们依次替换为对于工厂方法的调用，同时将创建产品的代码移入工厂方法。
    > 我们可能需要在工厂方法中添加很多临时参数来控制返回的产品类型，这样会让代码看上去非常糟糕，比如可能会看到复杂的
    `switch` 分支运算符，用于选择各种需要实例化的产品类，不用过于担心，后续会很快修复这个问题。
4. 现在，为工厂方法中的每个产品编写一个创建者子类，然后在子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。
5. 如果应用中的产品类型太多，那么为每个产品创建子类并无太大必要，这时你也可以在子类中复用基类中的控制参数。
    > 比如：假设我们有以下一些层次结构的类：
    > - 基类`邮件`及其子类`航空邮件`和`陆路邮件` 
    > - 基类`运输`及其子类`飞机`、`卡车` 和 `火车`
    > - `航空邮件`只会使用`飞机`对象，而陆路邮件则会同时使用卡车和火车对象
    > - 我们可以编写一个新的子类（例如：火车邮件）来处理这两种情况
    > - 还可以让客户端代码给陆路邮件类传递一个参数，用来控制其希望获得的产品
6. 如果代码经过上述移动后，基础工厂方法中以及没有任何代码，我们就可以将其转变为抽象类。如果基础工厂中还有其他语句，我们就可以将其设置为该方法的默认行为。

### 优缺点

#### 优点
1. 我们可以避免创建者和具体产品之间的紧密耦合。
2. 单一职责原则。我们可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。
3. 开闭原则。我们不需要更改现有客户端代码，就可以在程序中引入新的产品类型。
#### 缺点
1. 使用工厂方法模式需要引入很多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。

### 与其他设计模式的关系
1. 在设计工作初期，我们都会使用**工厂方法模式**（比较简单，方便通过子类进行定制），逐步会演化为**抽象工厂模式**、**原型模式**或**生成器模式**（更加灵活且更加复杂）
2. **抽象工厂模式**通常基于一个**工厂方法**，我们也可以使用**原型模式**来生成这些类的方法。
3. 我们可以同时使用**工厂方法**和**迭代器模式**来让子类集合返回不同类型的迭代器，并使得迭代器与集合相匹配
4. **原型**并不基于继承，因此没有继承的缺点，但是需要对被复制对象进行复杂的初始化。**工厂方法**基于继承，但是它不需要初始化步骤。
5. **工厂方法**是**模板方法模式**的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤。



